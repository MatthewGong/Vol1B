import pysg
import time
import numpy as np


from matplotlib import pyplot as plt


def hat_approximation(f,l):
    """This function will return a list of the correct coefficients to approximate the function f up to level l.
    Parameters
    ----------
        f (function) : The function of a single variable to approximate
        l (int) : The order to use for interpolating the hat function

    Returns
    -------
        coeffs (list) : Entry n is an ndarray of len(2^(n-1)) and contains the coefficients for phi_{nm}.  The length of this should be l.
    """

    coeffs = []

    def phi(x):
        # compact support on  [-1,1]
        if (x >= -1) and (x <= 1) :
            return 1 - abs(x)

        # outside the boundary of support, set as zero
        return 0

    phi_j_i = lambda j,i,x: phi(2**(j-1)*(x+1) - 2*i + 1)

    # double sum approximation of f(x) 
    for n in xrange(1, l+1):

        # define coefficient holder
        c_n = np.empty(2**(n-1))

        # second sum
        for m in xrange(1, 2**(n-1) + 1):

            pnm = 2**(2-n)*(m-.5) - 1

            func_pnm = f(pnm)

            # double sum defintion of cnm
            for s in xrange(1,n):
                for t in xrange(1, 2**(s-1) + 1):
                    func_pnm -= coeffs[s-1][t-1] * phi_j_i(s,t,pnm)
            
            # update coeffecient 
            c_n[m-1] = func_pnm

        # after all of that we just add the list of coeffs
        coeffs.append(c_n)

    return coeffs

def integrate_hat(coeffs):
    """Takes a list of coefficients generated by hat_approximation.
    Returns the value of the integral.
    Parameters
    ----------
        coeffs (ndarray) : coefficients generated by hat_approximation
    Returns
    ----------
    Value of the integral
    """

    # add the area of under the curve for each of the coeffs to approximate the integral
    area = 0

    # for each set of coeffs
    for i in xrange(len(coeffs)):
        # for each coeff in set
        for j in xrange(len(coeffs[i])):
            area += coeffs[i][j]*2. **(-i)

    return area
    
def prob3():
    """Create and show 2 graphs. One displays error and the other displays 
    execution time.
    """
    f = lambda x: np.sqrt(1.-x**2)

    errors = []
    times  = []

    ls     = range(0,11) 

    for l in ls:
        start    = time.time()
        coeffs   = hat_approximation(f,l)
        integral = integrate_hat(coeffs)
        
        errors.append(np.pi/2. - integral)
        times. append(time.time() - start)

    plt.xlim(1, 10)
    plt.ylim(0, .6)

    # Display times
    plt.plot(errors)
    plt.show()

    #display errors
    plt.plot(times)
    plt.show()


def prob4():
    """Plot the grid points for a 2-D grid of level 5.
    """
    sparse_grid = pysg.sparseGrid(2,5)
    sparse_grid.generatePoints()
    sparse_grid.plotGrid()